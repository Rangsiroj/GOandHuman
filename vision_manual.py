
# -----------------------------
# VisionManual: ‡∏£‡∏∞‡∏ö‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏´‡∏°‡∏≤‡∏Å‡πÅ‡∏ö‡∏ö Manual
# -----------------------------

import cv2
import numpy as np
import time
from board_mapper_manual import get_board_position  # ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡∏û‡∏¥‡∏Å‡∏±‡∏î pixel ‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ö‡∏ô‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô
from gnugo_text_game import GNUGo  # ‡∏Ñ‡∏•‡∏≤‡∏™‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏° AI ‡πÇ‡∏Å‡∏∞

# manual_pts: ‡πÄ‡∏Å‡πá‡∏ö‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏Ñ‡∏•‡∏¥‡∏Å‡πÄ‡∏•‡∏∑‡∏≠‡∏Å 4 ‡∏°‡∏∏‡∏°‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô
manual_pts = []

# ‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏ß‡πà‡∏≤‡∏á‡∏Ç‡∏≠‡∏á‡∏†‡∏≤‡∏û‡∏î‡πâ‡∏ß‡∏¢ CLAHE ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏û‡∏¥‡πà‡∏° contrast
def auto_adjust_brightness(gray_image):
    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
    return clahe.apply(gray_image)

# ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô callback ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏Ñ‡∏•‡∏¥‡∏Å‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏à‡∏∏‡∏î‡∏ö‡∏ô‡∏†‡∏≤‡∏û
def select_point(event, x, y, flags, param):
    if event == cv2.EVENT_LBUTTONDOWN and len(manual_pts) < 4:
        manual_pts.append([x, y])
        print(f"üìç ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà {len(manual_pts)}: ({x}, {y})")

# ‡πÅ‡∏õ‡∏•‡∏á‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ö‡∏ô‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô (‡πÄ‡∏ä‡πà‡∏ô 'A19') ‡πÄ‡∏õ‡πá‡∏ô‡∏û‡∏¥‡∏Å‡∏±‡∏î pixel ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•
def board_to_pixel(position):
    if len(position) < 2:
        return (0, 0)
    col = ord(position[0].upper()) - ord('A')
    row = 19 - int(position[1:])
    x = int((col / 18) * 500)
    y = int((row / 18) * 500)
    return (x, y)

# ‡∏Ñ‡∏•‡∏≤‡∏™‡∏´‡∏•‡∏±‡∏Å‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏∞‡∏ö‡∏ö Vision ‡πÅ‡∏ö‡∏ö Manual
class VisionManual:
    def __init__(self, url='http://172.23.36.213:4747/video'):
        # ‡πÄ‡∏õ‡∏¥‡∏î‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏à‡∏≤‡∏Å URL ‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î
        self.cap = cv2.VideoCapture(url)
        if not self.cap.isOpened():
            print("‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÑ‡∏î‡πâ")
        else:
            print("‚úÖ ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à")
        # ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô, ‡∏™‡∏µ‡∏ó‡∏µ‡πà‡πÄ‡∏•‡πà‡∏ô, ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏´‡∏°‡∏≤‡∏Å, ‡∏Ø‡∏•‡∏Ø
        self.board_state = {}
        self.current_turn = 'black'
        self.last_board_count = 0
        self.frame_count = 0
        self.prev_gray = None
        self.last_motion_time = time.time()
        self.motion_cooldown = 1.0

        # ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏≠‡πá‡∏≠‡∏ö‡πÄ‡∏à‡πá‡∏Å‡∏ï‡πå AI ‡πÇ‡∏Å‡∏∞ ‡πÅ‡∏•‡∏∞‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô
        self.gnugo = GNUGo()
        self.gnugo.clear_board()

    # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏ô‡∏¥‡πà‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà ‡πÇ‡∏î‡∏¢‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö‡∏†‡∏≤‡∏û‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤
    def is_camera_stable(self, gray, threshold=500000):
        now = time.time()
        if self.prev_gray is None:
            self.prev_gray = gray
            self.last_motion_time = now
            return True
        diff = cv2.absdiff(self.prev_gray, gray)
        score = np.sum(diff)
        self.prev_gray = gray
        if score > threshold:
            self.last_motion_time = now
            return False
        return (now - self.last_motion_time) > self.motion_cooldown

    # ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏•‡∏±‡∏Å‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏±‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏´‡∏°‡∏≤‡∏Å‡πÅ‡∏ö‡∏ö Manual
    def run(self):
        print("üì∑ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Ñ‡∏•‡∏¥‡∏Å‡πÄ‡∏•‡∏∑‡∏≠‡∏Å 4 ‡∏°‡∏∏‡∏°‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ó‡∏≥ Perspective Transform (ESC ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏≠‡∏≠‡∏Å)")

        # ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á‡πÅ‡∏•‡∏∞ trackbar ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏±‡∏ö brightness, contrast, threshold
        cv2.namedWindow("Manual Detection")
        cv2.setMouseCallback("Manual Detection", select_point)
        cv2.createTrackbar('Brightness', "Manual Detection", 76, 100, lambda x: None)
        cv2.createTrackbar('Contrast', "Manual Detection", 47, 100, lambda x: None)
        cv2.createTrackbar('White Threshold', "Manual Detection", 252, 255, lambda x: None)
        cv2.createTrackbar('Black Threshold', "Manual Detection", 72, 255, lambda x: None)

        while True:
            ret, frame = self.cap.read()
            if not ret:
                print("‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏∂‡∏á‡∏†‡∏≤‡∏û‡∏à‡∏≤‡∏Å‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÑ‡∏î‡πâ")
                break

            self.frame_count += 1
            if self.frame_count % 10 != 0:
                continue

            # ‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å trackbar ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡∏£‡∏±‡∏ö‡∏†‡∏≤‡∏û
            brightness = cv2.getTrackbarPos('Brightness', "Manual Detection") - 50
            contrast = cv2.getTrackbarPos('Contrast', "Manual Detection") / 50
            white_thresh = cv2.getTrackbarPos('White Threshold', "Manual Detection")
            black_thresh = cv2.getTrackbarPos('Black Threshold', "Manual Detection")

            frame = cv2.convertScaleAbs(frame, alpha=contrast, beta=brightness)
            frame_copy = frame.copy()
            gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏ô‡∏¥‡πà‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
            if not self.is_camera_stable(gray):
                # ‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏Ç‡∏¢‡∏±‡∏ö ‡∏£‡∏≠‡πÉ‡∏´‡πâ‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡πà‡∏≠‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏´‡∏°‡∏≤‡∏Å
                cv2.imshow("Manual Detection", frame_copy)
                if cv2.waitKey(1) & 0xFF == 27:
                    break
                continue

            # ‡∏ñ‡πâ‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ñ‡∏£‡∏ö 4 ‡∏à‡∏∏‡∏î‡πÅ‡∏•‡πâ‡∏ß ‡∏à‡∏∞‡∏ó‡∏≥ Perspective Transform ‡πÅ‡∏•‡∏∞‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏´‡∏°‡∏≤‡∏Å
            if len(manual_pts) == 4:
                try:
                    src_pts = np.float32(manual_pts)
                    dst_pts = np.float32([[0, 0], [500, 0], [500, 500], [0, 500]])
                    matrix = cv2.getPerspectiveTransform(src_pts, dst_pts)
                    warped = cv2.warpPerspective(frame, matrix, (500, 500))

                    enhanced_color = warped.copy()
                    gray = cv2.cvtColor(warped, cv2.COLOR_BGR2GRAY)
                    enhanced = auto_adjust_brightness(gray)
                    blurred = cv2.GaussianBlur(enhanced, (5, 5), 0)

                    # ‡∏™‡∏£‡πâ‡∏≤‡∏á mask ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏´‡∏°‡∏≤‡∏Å‡∏î‡∏≥‡πÅ‡∏•‡∏∞‡∏´‡∏°‡∏≤‡∏Å‡∏Ç‡∏≤‡∏ß
                    BW_black = cv2.threshold(blurred, black_thresh, 255, cv2.THRESH_BINARY_INV)[1]
                    BW_white = cv2.threshold(blurred, white_thresh, 255, cv2.THRESH_BINARY)[1]

                    kernel = np.ones((5, 5), np.uint8)
                    BW_black = cv2.morphologyEx(BW_black, cv2.MORPH_OPEN, kernel)
                    BW_white = cv2.morphologyEx(BW_white, cv2.MORPH_OPEN, kernel)

                    captured_positions = []
                    previous_board_state = self.board_state.copy()

                    # ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏´‡∏°‡∏≤‡∏Å‡∏Ç‡∏≤‡∏ß‡πÅ‡∏•‡∏∞‡∏î‡∏≥‡πÉ‡∏ô‡∏†‡∏≤‡∏û
                    for mask, color in [(BW_white, "white"), (BW_black, "black")]:
                        contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
                        detected_positions = set()

                        for cnt in contours:
                            (x, y), r = cv2.minEnclosingCircle(cnt)
                            area = cv2.contourArea(cnt)
                            perimeter = cv2.arcLength(cnt, True)
                            circularity = 4 * np.pi * area / (perimeter ** 2) if perimeter > 0 else 0

                            # ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏´‡∏°‡∏≤‡∏Å
                            if 6 <= r <= 15 and 0.7 <= circularity <= 1.2 and 50 <= area <= 500:
                                board_pos = get_board_position(int(x), int(y))
                                if board_pos:
                                    detected_positions.add(board_pos)

                        previous_positions = {pos for pos, c in self.board_state.items() if c == color}
                        diff = detected_positions - previous_positions

                        # ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏≤‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡πÅ‡∏•‡∏∞‡∏°‡∏µ‡∏´‡∏°‡∏≤‡∏Å‡πÉ‡∏´‡∏°‡πà 1 ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á
                        if color == self.current_turn and len(diff) == 1:
                            board_pos = diff.pop()
                            self.board_state[board_pos] = color
                            print(f"‚úÖ {color.upper()} ‡πÄ‡∏î‡∏¥‡∏ô‡∏ó‡∏µ‡πà {board_pos}")
                            self.gnugo.play_move(color, board_pos)

                            if color == 'black':
                                # ‡πÉ‡∏´‡πâ AI ‡πÄ‡∏î‡∏¥‡∏ô‡∏´‡∏°‡∏≤‡∏Å‡∏Ç‡∏≤‡∏ß
                                ai_move = self.gnugo.genmove('white')
                                print(f"ü§ñ AI (WHITE) ‡πÄ‡∏î‡∏¥‡∏ô‡∏ó‡∏µ‡πà: {ai_move}")
                                self.board_state[ai_move] = 'white'

                                # ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏à‡∏±‡∏ö‡∏Å‡∏¥‡∏ô
                                captured_positions = [pos for pos in previous_board_state
                                                      if pos not in self.board_state and previous_board_state[pos] != 'white']
                                if captured_positions:
                                    print(f"üí• ‡∏à‡∏±‡∏ö‡∏Å‡∏¥‡∏ô‡∏ó‡∏µ‡πà: {', '.join(captured_positions)}")

                                self.last_board_count = len(self.board_state)
                                time.sleep(0.5)

                            self.current_turn = 'black'

                    # ‡∏ß‡∏≤‡∏î‡∏ß‡∏á‡∏Å‡∏•‡∏°‡πÅ‡∏™‡∏î‡∏á‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏à‡∏±‡∏ö‡∏Å‡∏¥‡∏ô
                    for pos in captured_positions:
                        px, py = board_to_pixel(pos)
                        cv2.circle(enhanced_color, (px, py), 15, (0, 0, 255), 2)

                    # ‡πÅ‡∏™‡∏î‡∏á‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏ó‡∏µ‡πà‡∏õ‡∏£‡∏∞‡πÄ‡∏°‡∏¥‡∏ô‡πÇ‡∏î‡∏¢ AI
                    score = self.gnugo.send_command("estimate_score")
                    cv2.putText(enhanced_color, f"Score: {score}", (10, 480), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 0, 0), 2)

                    # ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏†‡∏≤‡∏û‡∏ï‡πà‡∏≤‡∏á ‡πÜ
                    cv2.imshow("Perspective View", enhanced_color)
                    cv2.imshow("Black Stones", BW_black)
                    cv2.imshow("White Stones", BW_white)

                except Exception as e:
                    print(f"‚ö†Ô∏è Transform Error: {e}")
            else:
                # ‡∏ß‡∏≤‡∏î‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ö‡∏ô‡∏†‡∏≤‡∏û‡πÅ‡∏•‡∏∞‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥
                for pt in manual_pts:
                    cv2.circle(frame_copy, tuple(pt), 5, (0, 255, 255), -1)
                cv2.putText(frame_copy, "‡∏Ñ‡∏•‡∏¥‡∏Å‡πÄ‡∏•‡∏∑‡∏≠‡∏Å 4 ‡∏°‡∏∏‡∏°‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô", (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 255), 2)

            cv2.imshow("Manual Detection", frame_copy)
            if cv2.waitKey(1) & 0xFF == 27:
                break

        self.release()

    # ‡∏õ‡∏¥‡∏î‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÅ‡∏•‡∏∞‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏à‡∏ö‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô
    def release(self):
        self.cap.release()
        cv2.destroyAllWindows()
        self.gnugo.quit()
        print("üîï ‡∏õ‡∏¥‡∏î‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÅ‡∏•‡∏∞ AI ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß")
